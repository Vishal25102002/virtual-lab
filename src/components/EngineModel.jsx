import React, { useRef, useEffect, useState } from 'react';
import { useGLTF } from '@react-three/drei';
import { useFrame, useThree } from '@react-three/fiber';
import * as THREE from 'three';
import { useGesture } from 'react-use-gesture';

// Engine part details data
const ENGINE_PARTS_DETAILS = {
  "cylinder": {
    name: "Cylinder",
    description: "The cylinder is where the combustion process occurs, converting the energy from burning fuel into mechanical force.",
    specs: "Cast iron, 4-inch diameter",
    function: "Contains and directs the power generated by the combustion process."
  },
  "piston": {
    name: "Piston",
    description: "The piston transfers force from expanding gas in the cylinder to the crankshaft via the connecting rod.",
    specs: "Aluminum alloy, 3.9-inch diameter",
    function: "Converts pressure from combustion into linear motion."
  },
  "crankshaft": {
    name: "Crankshaft",
    description: "The crankshaft converts the linear motion of the pistons into rotational motion.",
    specs: "Forged steel, 24-inch length",
    function: "Transfers rotational energy to the transmission system."
  },
  "camshaft": {
    name: "Camshaft",
    description: "The camshaft controls the opening and closing of the engine's valves.",
    specs: "Hardened steel, timing gear driven",
    function: "Controls valve operation timing for intake and exhaust processes."
  },
  "valve": {
    name: "Valve",
    description: "Valves allow air-fuel mixture into the cylinder and exhaust gases out.",
    specs: "Stainless steel, 1.2-inch diameter",
    function: "Seals combustion chamber during compression and power strokes."
  },
  "rod": {
    name: "Connecting Rod",
    description: "The connecting rod connects the piston to the crankshaft.",
    specs: "Forged steel, I-beam design",
    function: "Transfers force from the piston to the crankshaft."
  },
  "block": {
    name: "Engine Block",
    description: "The engine block is the main structure that houses the cylinders and supports the crankshaft.",
    specs: "Cast aluminum alloy with iron sleeves",
    function: "Provides the structural foundation for all engine components."
  },
  "head": {
    name: "Cylinder Head",
    description: "The cylinder head seals the top of the cylinders and houses the valves and spark plugs.",
    specs: "Aluminum alloy, 4-valve design",
    function: "Contains combustion chambers and passages for intake and exhaust."
  },
  "pan": {
    name: "Oil Pan",
    description: "The oil pan serves as a reservoir for engine oil.",
    specs: "Stamped steel, 5-quart capacity",
    function: "Stores lubricating oil and helps cool it before recirculation."
  },
};

// Generic fallback for unidentified parts
const DEFAULT_PART_DETAILS = {
  name: "Engine Part",
  description: "This is a component of the internal combustion engine.",
  specs: "Manufactured to precision specifications",
  function: "Contributes to the overall engine operation."
};

export default function EngineModelWithLab({ position = [0, 0, 0] }) {
  const engineRef = useRef();
  const labEnvRef = useRef();

  // For zoom (mouse wheel / pinch)
  const [scale, setScale] = useState(1.0);

  // For dragging rotation
  const rotationRef = useRef({ x: 0, y: 0, z: 0 });
  const dragDistanceRef = useRef(0);
  const isDraggingRef = useRef(false);

  // Store original transforms and track exploded parts
  const originalPartsDataRef = useRef({});
  const explodedPartsRef = useRef({});

  // Hover state for part details
  const [hoveredPart, setHoveredPart] = useState(null);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  const [isHoverCardVisible, setIsHoverCardVisible] = useState(false);

  // Load the GLTF model
  const { scene: gltfScene } = useGLTF('/enginev8label.glb');
  // Access the Three.js scene
  const { scene, camera, gl } = useThree();

  // Track mouse position for the hover card
  useEffect(() => {
    const updateMousePosition = (e) => {
      setMousePosition({ x: e.clientX, y: e.clientY });
    };
    window.addEventListener('mousemove', updateMousePosition);
    return () => {
      window.removeEventListener('mousemove', updateMousePosition);
    };
  }, []);

  // Setup hover card DOM element with creative styling
  useEffect(() => {
    let container = document.getElementById('engine-hover-card-container');
    if (!container) {
      container = document.createElement('div');
      container.id = 'engine-hover-card-container';
      document.body.appendChild(container);
    }
    
    if (hoveredPart && !isDraggingRef.current) {
      const hoverCard = document.createElement('div');
      hoverCard.style.position = 'fixed';
      hoverCard.style.left = `${mousePosition.x + 15}px`;
      hoverCard.style.top = `${mousePosition.y + 15}px`;
      // Creative card design
      hoverCard.style.background = 'linear-gradient(135deg, #1c1c1c, #323232)';
      hoverCard.style.border = '2px solid #3e9fff';
      hoverCard.style.borderRadius = '10px';
      hoverCard.style.padding = '12px';
      hoverCard.style.maxWidth = '280px';
      hoverCard.style.zIndex = '10000';
      hoverCard.style.pointerEvents = 'none';
      hoverCard.style.boxShadow = '0px 8px 16px rgba(0, 0, 0, 0.6)';
      hoverCard.style.fontFamily = '"Roboto", sans-serif';
      hoverCard.style.color = '#ffffff';
      
      hoverCard.innerHTML = `
        <h3 style="margin: 0 0 8px 0; color: #3e9fff;">${hoveredPart.name}</h3>
        <p style="margin: 0 0 8px 0; font-size: 14px;">${hoveredPart.description}</p>
        <div style="font-size: 13px; margin: 5px 0">
          <div><strong>Specs:</strong> ${hoveredPart.specs}</div>
          <div><strong>Function:</strong> ${hoveredPart.function}</div>
        </div>
        <div style="font-size: 12px; margin-top: 5px; color: #ffcc00; font-style: italic;">
          Click to disassemble
        </div>
      `;
      
      container.innerHTML = '';
      container.appendChild(hoverCard);
      setIsHoverCardVisible(true);
    } else {
      container.innerHTML = '';
      setIsHoverCardVisible(false);
    }
    
    return () => {
      if (container && document.body.contains(container)) {
        document.body.removeChild(container);
      }
    };
  }, [hoveredPart, mousePosition, isDraggingRef.current]);

  // Add an ambient light to the scene once
  useEffect(() => {
    if (!scene.getObjectByName('enhancedAmbientLight')) {
      const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
      ambientLight.name = 'enhancedAmbientLight';
      scene.add(ambientLight);
    }
    return () => {
      const existingLight = scene.getObjectByName('enhancedAmbientLight');
      if (existingLight) scene.remove(existingLight);
    };
  }, [scene]);

  // Find part details from name
  const getPartDetails = (partName) => {
    if (!partName) return DEFAULT_PART_DETAILS;
    
    const lowerName = partName.toLowerCase();
    for (const key in ENGINE_PARTS_DETAILS) {
      if (lowerName.includes(key)) {
        return ENGINE_PARTS_DETAILS[key];
      }
    }
    return {
      ...DEFAULT_PART_DETAILS,
      name: partName.charAt(0).toUpperCase() + partName.slice(1)
    };
  };

  // Setup the engine model and record original part transforms
  useEffect(() => {
    if (!gltfScene || !engineRef.current) return;
    let engineRoot = gltfScene.getObjectByName('Engine');
    if (!engineRoot) {
      console.warn('Engine node not found; using entire GLTF scene.');
      engineRoot = gltfScene.clone();
    } else {
      engineRoot = engineRoot.clone();
    }

    const globalBox = new THREE.Box3();
    engineRoot.updateMatrixWorld(true);

    engineRoot.traverse((child) => {
      if (child.isMesh) {
        // Save original transform data
        originalPartsDataRef.current[child.uuid] = {
          position: child.position.clone(),
          rotation: child.rotation.clone(),
          scale: child.scale.clone(),
          parent: child.parent
        };

        child.geometry?.computeBoundingBox();
        globalBox.expandByObject(child);

        // Flag the part as not exploded
        child.userData.isExplodedPart = false;

        // Clone and tweak material properties
        if (child.material) {
          child.material = child.material.clone();
          child.material.roughness = 0.3;
          child.material.metalness = 0.8;
        }

        // Name the part for debugging
        child.userData.partName = child.name || `Part_${child.uuid.slice(0, 5)}`;
        // Associate part details data
        child.userData.details = getPartDetails(child.userData.partName);
      }
    });

    // Scale and center the engine model based on the computed bounding box
    if (!globalBox.isEmpty()) {
      const size = globalBox.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const scaleFactor = maxDim > 0 ? 10 / maxDim : 1;
      engineRoot.scale.setScalar(scaleFactor);
      engineRoot.updateMatrixWorld(true);
      const scaledBox = new THREE.Box3().setFromObject(engineRoot);
      engineRoot.position.y -= scaledBox.min.y;
    } else {
      console.warn('Global bounding box is empty! Using fallback scale.');
      engineRoot.scale.setScalar(10);
    }

    // Offset the engine model using props
    engineRoot.position.x += position[0];
    engineRoot.position.y += position[1];
    engineRoot.position.z += position[2];

    // Clear any previous children and add the engine model to the engine group
    while (engineRef.current.children.length > 0) {
      engineRef.current.remove(engineRef.current.children[0]);
    }
    engineRef.current.add(engineRoot);
  }, [gltfScene, position]);

  // Update engine rotation and scale each frame
  useFrame(() => {
    if (engineRef.current) {
      engineRef.current.rotation.x = rotationRef.current.x;
      engineRef.current.rotation.y = rotationRef.current.y;
      engineRef.current.rotation.z = rotationRef.current.z;
      engineRef.current.scale.set(scale, scale, scale);
    }
  });

  // Handle raycasting for hover effects
  useFrame(({ raycaster, mouse }) => {
    if (isDraggingRef.current) {
      if (hoveredPart) setHoveredPart(null);
      return;
    }
    raycaster.setFromCamera(mouse, camera);
    const meshes = [];
    if (engineRef.current) {
      engineRef.current.traverse((node) => {
        if (node.isMesh) meshes.push(node);
      });
    }
    if (labEnvRef.current) {
      labEnvRef.current.traverse((node) => {
        if (node.isMesh) meshes.push(node);
      });
    }
    
    const intersects = raycaster.intersectObjects(meshes, false);
    if (intersects.length > 0) {
      const object = intersects[0].object;
      setHoveredPart(object.userData.details);
      if (gl.domElement && typeof gl.domElement.style.cursor === 'string') {
        gl.domElement.style.cursor = 'pointer';
      }
    } else {
      setHoveredPart(null);
      if (gl.domElement && typeof gl.domElement.style.cursor === 'string') {
        gl.domElement.style.cursor = 'auto';
      }
    }
  });

  // Animate part dropping into the lab environment (explode)
  const movePartToLab = (part, index) => {
    part.userData.isExplodedPart = true;
    explodedPartsRef.current[part.uuid] = part;
    if (part.parent) {
      part.parent.remove(part);
    }
    if (labEnvRef.current) {
      labEnvRef.current.add(part);
    }
    const gridStart = [0, 0.5, 12];
    const spacing = 3;
    const partsPerRow = 4;
    const row = Math.floor(index / partsPerRow);
    const col = index % partsPerRow;
    const centerOffset = (partsPerRow * spacing) / 2;
    const xPos = gridStart[0] + col * spacing - centerOffset + spacing / 2;
    const yPos = gridStart[1];
    const zPos = gridStart[2] - row * spacing;
    // Set initial position for a drop effect
    part.position.set(xPos, yPos + 5, zPos);
    part.rotation.set(0, Math.PI / 4, 0);
    part.scale.set(1.5, 1.5, 1.5);
    part.userData.targetPos = { x: xPos, y: yPos, z: zPos };
    const dropAnim = () => {
      if (!part.userData.isExplodedPart) return;
      const distY = part.userData.targetPos.y - part.position.y;
      if (Math.abs(distY) > 0.05) {
        part.position.y += distY * 0.1;
        requestAnimationFrame(dropAnim);
      } else {
        part.position.y = part.userData.targetPos.y;
      }
    };
    dropAnim();
  };

  // Merge parts instantly back to the engine
  const movePartBackToEngine = (part) => {
    const originalData = originalPartsDataRef.current[part.uuid];
    if (!originalData) {
      console.warn('No original data for part', part.uuid);
      return;
    }
    // Reset the part to its original transform immediately.
    part.position.copy(originalData.position);
    part.rotation.copy(originalData.rotation);
    part.scale.copy(originalData.scale);
    if (part.parent) part.parent.remove(part);
    originalData.parent.add(part);
    part.userData.isExplodedPart = false;
    delete explodedPartsRef.current[part.uuid];
  };

  // Use a single gesture binding for both engine and lab groups.
  const bind = useGesture(
    {
      onDrag: ({ delta: [dx, dy], event, first, last }) => {
        if (event && typeof event.stopPropagation === 'function') {
          event.stopPropagation();
        }
        if (first) {
          dragDistanceRef.current = 0;
          isDraggingRef.current = true;
          document.body.style.cursor = 'grabbing';
        }
        rotationRef.current.y += dx * 0.01;
        rotationRef.current.x += dy * 0.01;
        dragDistanceRef.current += Math.abs(dx) + Math.abs(dy);
        if (last) {
          isDraggingRef.current = false;
          document.body.style.cursor = 'auto';
        }
      },
      onPinch: ({ delta: [d], event }) => {
        if (event && typeof event.stopPropagation === 'function') {
          event.stopPropagation();
        }
        if (event && typeof event.preventDefault === 'function') {
          event.preventDefault();
        }
        const zoomSpeed = 0.01;
        let newScale = scale + d * zoomSpeed;
        newScale = Math.min(Math.max(newScale, 0.5), 2.0);
        setScale(newScale);
      },
      onWheel: ({ delta: [, dy], event }) => {
        if (event && typeof event.stopPropagation === 'function') {
          event.stopPropagation();
        }
        if (event && typeof event.preventDefault === 'function') {
          event.preventDefault();
        }
        const zoomSpeed = 0.001;
        let newScale = scale - dy * zoomSpeed;
        newScale = Math.min(Math.max(newScale, 0.5), 2.0);
        setScale(newScale);
      },
      onClick: ({ event }) => {
        if (event && typeof event.stopPropagation === 'function') {
          event.stopPropagation();
        }
        if (dragDistanceRef.current < 10) {
          const mesh = event.object;
          if (mesh && mesh.isMesh) {
            if (!mesh.userData.isExplodedPart) {
              console.log(`Exploding part ${mesh.userData.partName}`);
              const index = Object.keys(explodedPartsRef.current).length;
              movePartToLab(mesh, index);
            } else {
              console.log(`Merging part ${mesh.userData.partName}`);
              movePartBackToEngine(mesh);
            }
          }
        }
      }
    },
    { eventOptions: { passive: false } }
  );

  return (
    <>
      <group ref={engineRef} {...bind()} />
      <group ref={labEnvRef} name="LabEnvironment" {...bind()} />
    </>
  );
}
